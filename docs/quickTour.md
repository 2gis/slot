#Общие принципы

Slot позволяет проинициализировать приложение на сервере, передать клиенту собранную верстку и, при завершении инициализации на клиенте, привязать события к DOM-нодам.

##Этапы жизни приложения

Приложение имеет свои этапы жизни.
Этапов два.
Первый этап `init`: выполняется начальная инициализация модулей, затем рендеринг модулей в строку,
и наконец, строка обрабатывается браузером и преобразуется в DOM-дерево.

Второй этап `bind`: этап инициализации приложения после того, как стало доступно DOM-дерево собранное в результате работы модулей.

* `app._stage` - переменная содержит в себе название текущего этапа.
* `slot.domBound()` - возвращает true если сейчас активен второй этап `bind`.

Просьба не пользоваться логикой onClient/onServer для определения этих этапов.
Первый этап вначале выполняется на сервере, второй на клиенте.

##Принципы построения приложения

###Модули

 - Имеют визуальное представление.
 - Иерархически вкладываются друг в друга.
 - Знают только о дочерних модулях.
 - Могут сообщать наверх об изменении своего состояния.
 - Могут давать команды вложенным модулям, чтобы те изменили свое состояние.

####Из чего состоит модуль

 - js код
 - шаблоны
 - стили

####Кратко про модуль

Модуль - это сущность, которая содержит шаблон, отображение. Все отображение проекта состоит из модулей.
Полная операция подключения модуля состоит из 4 шагов:

* загрузка модуля `app.loadModule()`
* инициализация модуля `module.init()`
* рендер модуля `module.render()` и `append` отрендеренного html к родителю
* биндинг модуля `module.bindEvents()`

##### loadModule
Создает `slot` и `инстанс модуля`, причем возвращается "обернутый" инстанс модуля `moduleWrapper`. Обертка включает в себя общие функции.

##### bindEvents
Навешивает события на дом элементы модуля с помощью `jQuery.on` (кроме событий `scroll`, `block`,`error`). Какие события? Которые мы указали в `module.elements`, например модуль `dashboard`, элемент с классом `dashboard__city-select`, событие `click` навешивается так:

    var dashboard = {
        init: function() { ... },
        ...
        elements: {
            citySelect: {
                click: function(event) { ... }
            }
        }
    };

После навешивания событий `bindEvents` вызывает `module.clientInit` и завершает все это вызовом `bindEvents` для ВСЕХ детей модуля.

##### bind
`bind` - функция в модуле, которая вызывается когда дом дерево модуля отрисовано и забиндено.
Также это второй шаг в операции `bindEvents` (после связывания событий и перед `bindEvents` для детей).
Предназначена для развешивания пользовательских событий, автоматически вызывается после отрисовки при вызове функции `rerender`

##### clientInit
`clientInit` - это функция в модуле, которая говорит о том, что дом дерево для модуля уже отрисовано и забиндено.
Вызывается один раз за все время жизни модуля, сразу после вызова `bind`.

##### Как подключить
Модуль можно подключить следующим способом:
`slot.init(name, data, callback)`, где

* name - тип модуля (например, firmCard),
* data (опционально) - данные для инициализации модуля, которые прилетят в инит модуля первым аргументом,
* callback - колбек, вызываемый инитом модуля асинхнонно, или враппером синхронно, если модуль синхронный и не имеет колбека в ините

Пример:

	slot.init('bookletSuggest', {
        name: 'street'
    },
    function(err, module) {
    	/* code */
    })

##### Перехват событий
* `interface` - перехватывает события, которые приходят от родительских модулей. Возникают с помощью метода `slot.broadcast` в родительском модуле.
* `dispatcher` - перехватывает события, которые приходят от нижестоящих по иерархии модулей. Возникают с помощью метода `slot.notify` в нижних модулях.


###Компоненты

 - Работают по паттерну singleton. Один инстанс компонента для всего приложения.
 - Решают общие задачи для всего приложения:
    - получение данных из внешних источников (например обращение в API за данными)
    - хранение и предобработка данных (например состояние приложения)
    - локализация приложения
    - другое
 - Могут скрывать в себе различную реализацию для серверной и клиентской части

###Хелперы

 - Работают по принципу статических функций.
 - Используются для вынесения общей логики манипуляции над данными.